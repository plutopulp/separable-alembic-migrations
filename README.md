This is an example of how to set up postgresql tables and migrations with sqlalchemy and alembic, when multiple applications connect to a single database.

We implement this by creating a database schema for each application and then tying all tables of an application to the respective schema. We create an alembic declarative_base model, `Base`, for each schema and ensure that autogenerated alembic version revisions for a given `Base` only target DB objects under that same schema.

# Starting the DB

To spin up the postgresql DB and adminer client for managing the DB content, run

```shell
make start-db
```

The DB client should then be available on your [localhost](http://localhost:8080). Login as user, `postgres`, password, `postgres` and database, `test_db`.
On initialisation, a `init.sql` script gets triggered which creates the DB schemas that each table set gets attached to. You should be able to see these schemas in the dropdown menu in adminer, alongside the default schemas, such as `public`, `pg_catalogue`, etc...

# Upgrade DB to head

To upgrade the database migrations of either of the applications to the head version, run

```shell
make upgrade-head app=TARGET_APP
```

Where TARGET_APP is one of the target service names in the docker-compose.yml.
After running this command for one of the apps, you should now see the tables for that app appear in the `Table and views`. Notice that an `alembic_version` table appears here also, which is responsible for recording all the versions of the tables under that schema.
Repeating this for the other target apps, you should then see all the new table sets generated in each DB schema, each with their own `alembic_version` table.

# Migrations

To perform auto-generated revisions for a given schema, update your `models.py` in one of the applications and then run:

```shell
make revision app=TARGET_APP m="YOUR_VERSION_MESSAGE"
```

You should see a new auto-generated migration file under `alembic/versions`, which should reflect the changes you have made to your models. No DB objects from other schemas should be referenced in this file.

To apply the migrations to the DB, upgrade your version to point to the head:

```shell
make upgrade-head app=TARGET_APP
```

# Implementation details

## Schema definitions

For each application, we create a PostgreSQL schema. In the example, this is achieved by bind mounting an `init.sql` file, e.g.

```SQL
CREATE SCHEMA IF NOT EXISTS auth AUTHORIZATION postgres;
CREATE SCHEMA IF NOT EXISTS billing AUTHORIZATION postgres;
```

to the postgres docker-compose service.

We ensure that any tables for a given app are attached to their respective schema, by configuration the metadata of the `Base` model:

```python
from sqlalchemy import MetaData
from sqlalchemy.orm import registry

mapper_registry = registry()
_Base = mapper_registry.generate_base()

class Base(_Base):
    ...
    metadata = MetaData(schema=os.environ["DB_SCHEMA"])
    ...
```

where the `DB_SCHEMA` is defined in each apps' environment.

## Migration configuration

We want the various applications to be able to migrate their respective DB objects (attached to their schema), independently from each other.
We also want to leverage the autogenerate feature of `alembic` to automatically generate the content of migration version files.
`alembic` achieves this by inspecting the difference in the current state of the DB and the current model definitions inheriting from the `Base` model.

```python
MIGRATIONS_CONFIG = dict(
    target_metadata=target_metadata,
    version_table="alembic_version",
    version_table_schema=DB_SCHEMA,
    include_schemas=True,
    include_name=include_name,
)
```

where `DB_SCHEMA = os.environ["DB_SCHEMA"]`

```python
def include_name(name, type_, parent_names):
    if type_ == "schema":
        return name in [DB_SCHEMA]
    return True
```
